<!DOCTYPE html>
<html lang="az">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#1b4d3e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Domino 101 Pro - Telegram Oyunu</title>

    <!-- Favicon - Tarayƒ±cƒ± sekmesi i√ßin ikon -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üé≤</text></svg>">

    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #1b4d3e;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23153d31' fill-opacity='0.4' fill-rule='evenodd'%3E%3Cpath d='M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z'/%3E%3C/g%3E%3C/svg%3E");
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
            font-family: 'Roboto', sans-serif;
            height: 100vh;
            width: 100vw;
            position: fixed;
        }

        #root {
            height: 100vh;
            width: 100vw;
        }

        .pip-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            padding: 2px;
        }

        .pip {
            background-color: #111;
            border-radius: 50%;
            width: 6px;
            height: 6px;
            margin: auto;
            box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.2);
        }

        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* DOMINO BOARD STYLES */
        .domino-board-container {
            width: 100%;
            height: 60vh;
            position: relative;
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(135deg, rgba(27, 77, 62, 0.95) 0%, rgba(15, 43, 35, 0.95) 100%);
            border: 3px solid rgba(255, 255, 255, 0.15);
            margin: 0;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5), 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .domino-board-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            will-change: transform;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .domino-tile {
            display: inline-flex;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 2px solid #222;
            border-radius: 6px;
            box-shadow: 0 3px 0 #aaa, 0 4px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            flex-shrink: 0;
        }

        .domino-tile.horizontal {
            flex-direction: row;
        }

        .domino-tile.vertical {
            flex-direction: column;
        }

        .domino-tile:active {
            transform: scale(0.95) !important;
        }


        .domino-tile-face {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .domino-divider {
            background: #222;
            position: absolute;
            z-index: 1;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        .domino-tile.horizontal .domino-divider {
            width: 2px;
            height: 85%;
            top: 7.5%;
            left: 50%;
            transform: translateX(-50%);
        }

        .domino-tile.vertical .domino-divider {
            height: 2px;
            width: 85%;
            left: 7.5%;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Ta≈ü boyutlarƒ± */
        .tile-size-hand {
            width: 38px;
            /* Dik durmasƒ± i√ßin */
            height: 76px;
            margin: 5px;
        }

        .tile-size-board {
            width: 60px;
            height: 30px;
        }

        /* Se√ßili ta≈ü efekti */
        .selected-tile {
            transform: translateY(-5px) scale(1.1) !important;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.8), 0 3px 0 #aaa, 0 6px 6px rgba(0, 0, 0, 0.4);
            z-index: 100;
            border-color: #f59e0b;
        }

        /* Valid Move Indicators */
        .valid-move-indicator {
            position: absolute;
            z-index: 50;
            border: 3px dashed rgba(251, 191, 36, 0.9);
            border-radius: 8px;
            background: rgba(251, 191, 36, 0.15);
            animation: pulse-glow 1.5s infinite;
            pointer-events: auto;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .valid-move-indicator:active {
            transform: scale(0.95);
            background: rgba(251, 191, 36, 0.3);
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(251, 191, 36, 0.6), 0 0 20px rgba(251, 191, 36, 0.3);
                border-color: rgba(251, 191, 36, 0.9);
            }

            50% {
                box-shadow: 0 0 20px rgba(251, 191, 36, 0.9), 0 0 40px rgba(251, 191, 36, 0.5);
                border-color: rgba(251, 191, 36, 1);
            }
        }

        /* Board ta≈ü pozisyonlarƒ± */
        .board-tile {
            position: absolute;
            pointer-events: none;
        }

        /* El ta≈ülarƒ± container - YATAY Dƒ∞Zƒ∞Lƒ∞M */
        .hand-tiles-container {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            padding: 10px;
            gap: 8px;
            align-items: center;
            justify-content: center;
            min-height: 70px;
            background: rgba(0, 0, 0, 0.3);
            scroll-snap-type: x mandatory;
        }

        .hand-tile-wrapper {
            scroll-snap-align: center;
            flex-shrink: 0;
        }

        /* Zoom hint */
        .zoom-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }

        /* Game controls */
        .game-controls {
            position: absolute;
            bottom: 15px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .control-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .control-button:active {
            transform: scale(0.9);
            background: rgba(0, 0, 0, 0.9);
        }

        /* Board zoom info */
        .board-zoom-info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Animation for new tiles */
        @keyframes tileSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tile-slide-in {
            animation: tileSlideIn 0.2s ease-out;
        }

        /* Turn indicator */
        .turn-indicator {
            animation: pulse-turn 2s infinite;
        }

        @keyframes pulse-turn {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 640px) {
            .tile-size-hand {
                width: 32px;
                height: 64px;
                margin: 3px;
            }

            .tile-size-board {
                width: 50px;
                height: 25px;
            }

            .domino-board-container {
                height: 55vh;
            }

            .hand-tiles-container {
                min-height: 65px;
                padding: 8px;
            }

            .zoom-hint {
                display: block;
            }
        }

        @media (min-width: 641px) and (max-width: 1024px) {
            .tile-size-hand {
                width: 35px;
                height: 70px;
            }

            .tile-size-board {
                width: 55px;
                height: 27px;
            }

            .domino-board-container {
                height: 60vh;
            }
        }

        /* PC i√ßin Telegram uyumu */
        @media (min-width: 1025px) {
            body {
                min-height: 600px;
                min-width: 350px;
            }

            .domino-board-container {
                height: 65vh;
            }

            .tile-size-hand {
                width: 40px;
                height: 80px;
            }

            .tile-size-board {
                width: 65px;
                height: 32px;
            }
        }

        /* Telegram WebApp i√ßin √∂zel stiller */
        .tg-webapp {
            background: transparent !important;
        }

        /* Oda kodu g√∂sterimi */
        .room-code-display {
            animation: room-code-pulse 2s infinite;
        }

        @keyframes room-code-pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        /* Loading spinner */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid #ffffff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Toast notification */
        .toast-notification {
            animation: toast-slide 0.3s ease-out, toast-fade 0.3s ease-out 2.7s;
        }

        @keyframes toast-slide {
            from {
                transform: translate(-50%, -100px);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        @keyframes toast-fade {
            to {
                opacity: 0;
            }
        }
    </style>
</head>

<body class="tg-webapp">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // Telegram WebApp Initialization
        const tg = window.Telegram?.WebApp;

        // Telegram SDK-ni i≈ü…ô sal
        if (tg) {
            tg.ready();
            tg.expand();
            tg.enableClosingConfirmation();
            console.log('‚úÖ Telegram WebApp SDK i≈ü…ô salƒ±ndƒ±');
        }

        // --- SABƒ∞T SUNUCU ADRESLERƒ∞ ---
        const API_URL = 'https://beta-github-io.onrender.com';
        const WS_URL = 'wss://beta-github-io.onrender.com';

        // --- Bƒ∞LE≈ûENLER ---
        const RenderPips = ({ number }) => {
            const layouts = {
                0: [], 1: [4], 2: [0, 8], 3: [0, 4, 8],
                4: [0, 2, 6, 8], 5: [0, 2, 4, 6, 8], 6: [0, 2, 3, 5, 6, 8]
            };
            const activePips = layouts[number] || [];
            return (
                <div className="pip-grid">
                    {[...Array(9)].map((_, i) => (
                        <div key={i} className="pip" style={{
                            opacity: activePips.includes(i) ? 1 : 0.2,
                            transform: activePips.includes(i) ? 'scale(1)' : 'scale(0.5)',
                            transition: 'all 0.2s ease'
                        }}></div>
                    ))}
                </div>
            );
        };

        const DominoTile = ({ values, onClick, disabled, isSelected, isBoardTile = false }) => {
            const handleClick = (e) => {
                e.stopPropagation();
                if (!disabled && onClick) {
                    onClick();
                }
            };

            const orientationClass = isBoardTile ? 'horizontal' : 'vertical';
            const baseClasses = `
                domino-tile relative flex overflow-hidden
                ${isSelected ? 'selected-tile' : ''}
                ${!disabled && !isBoardTile ? 'cursor-pointer hover:brightness-110 active:scale-95' : ''}
                ${disabled ? 'opacity-80 cursor-default' : ''}
                tile-slide-in
            `;

            const sizeClass = isBoardTile ? 'tile-size-board' : 'tile-size-hand';

            return (
                <div
                    onClick={handleClick}
                    className={`${baseClasses} ${sizeClass} ${orientationClass}`}
                >
                    <div className={`domino-tile-face ${orientationClass === 'horizontal' ? 'border-r-2' : 'border-b-2'} border-gray-800`}>
                        <RenderPips number={values[0]} />
                    </div>
                    <div className="domino-tile-face">
                        <RenderPips number={values[1]} />
                    </div>
                    <div className="domino-divider"></div>
                </div>
            );
        };

        const Toast = ({ message, type }) => {
            const colors = {
                success: 'bg-green-600',
                error: 'bg-red-600',
                info: 'bg-blue-600',
                warning: 'bg-yellow-600'
            };
            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };

            return (
                <div className={`fixed top-4 left-1/2 -translate-x-1/2 z-50 px-4 py-3 rounded-full shadow-xl text-white font-medium text-sm toast-notification flex items-center gap-2 ${colors[type] || colors.info}`}>
                    <span className="text-base">{icons[type] || icons.info}</span>
                    <span>{message}</span>
                </div>
            );
        };

        // --- ANA OYUN ---
        const DominoGame = () => {
            const LOCAL_STORAGE_ROOM = 'domino_roomCode';
            const LOCAL_STORAGE_PLAYER = 'domino_playerId';

            const [screen, setScreen] = useState('loading');
            const [connected, setConnected] = useState(false);
            const [playerData, setPlayerData] = useState(null);
            const [leaderboard, setLeaderboard] = useState([]);
            const [roomCode, setRoomCode] = useState('');
            const [joinCode, setJoinCode] = useState('');
            const [gameState, setGameState] = useState(null);
            const [searchTime, setSearchTime] = useState(0);

            // Oyun ƒ∞√ßi State
            const [selectedTileIndex, setSelectedTileIndex] = useState(null);
            const [validMoves, setValidMoves] = useState([]);
            const [notification, setNotification] = useState(null);
            const [searching, setSearching] = useState(false);
            const [endInfo, setEndInfo] = useState(null);
            const [opponent, setOpponent] = useState(null);
            const [reconnectAttemptCount, setReconnectAttemptCount] = useState(0);
            const MAX_RECONNECT_ATTEMPTS = 5;

            // Board Zoom ve Position State
            const [boardZoom, setBoardZoom] = useState(1);
            const [boardPosition, setBoardPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [pinchStart, setPinchStart] = useState({ distance: 0 });
            const [showZoomHint, setShowZoomHint] = useState(true);

            const wsRef = useRef(null);
            const boardContainerRef = useRef(null);
            const boardInnerRef = useRef(null);
            const searchTimerRef = useRef(null);
            const reconnectTimerRef = useRef(null);
            const lastTouchTimeRef = useRef(0);
            const zoomHintTimeoutRef = useRef(null);
            const connectionCheckRef = useRef(null);
            const initialLoadTimeoutRef = useRef(null);

            // Reset Game State
            const resetGameClientState = () => {
                setGameState(null);
                setRoomCode('');
                setSearching(false);
                setSelectedTileIndex(null);
                setValidMoves([]);
                setEndInfo(null);
                setOpponent(null);
                setJoinCode('');
                setBoardZoom(1);
                setBoardPosition({ x: 0, y: 0 });
                localStorage.removeItem(LOCAL_STORAGE_ROOM);
                localStorage.removeItem(LOCAL_STORAGE_PLAYER);
            };

            const showNotification = (msg, type = 'info') => {
                setNotification({ message: msg, type });
                setTimeout(() => setNotification(null), 3000);
            };

            // --- WebSocket Baƒülantƒ± ---
            const attemptReconnect = () => {
                if (reconnectAttemptCount >= MAX_RECONNECT_ATTEMPTS) {
                    showNotification('Server baƒülantƒ±sƒ± qurula bilm…ôdi. Z…ôhm…ôt olmasa s…ôhif…ôni yenil…ôyin.', 'error');
                    setScreen('lobby');
                    if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);
                    return;
                }

                const delay = Math.min(2000 * (reconnectAttemptCount + 1), 10000);
                setReconnectAttemptCount(prev => prev + 1);
                reconnectTimerRef.current = setTimeout(() => {
                    connectToServer();
                }, delay);
            };

            const connectToServer = () => {
                if (wsRef.current) {
                    const state = wsRef.current.readyState;
                    if (state === WebSocket.OPEN || state === WebSocket.CONNECTING) return;
                }

                if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);

                const ws = new WebSocket(WS_URL);
                wsRef.current = ws;

                ws.onopen = () => {
                    setConnected(true);
                    setReconnectAttemptCount(0);
                    showNotification('Server…ô qo≈üuldu ‚úÖ', 'success');

                    const storedRoomCode = localStorage.getItem(LOCAL_STORAGE_ROOM);
                    const storedPlayerId = localStorage.getItem(LOCAL_STORAGE_PLAYER);

                    if (storedRoomCode && storedPlayerId && screen !== 'lobby') {
                        setTimeout(() => {
                            sendMessage({
                                type: 'reconnect',
                                pokemonId: storedPlayerId, // Using correct ID field name
                                telegramId: storedPlayerId,
                                roomCode: storedRoomCode
                            });
                        }, 500);
                    } else {
                        localStorage.removeItem(LOCAL_STORAGE_ROOM);
                        localStorage.removeItem(LOCAL_STORAGE_PLAYER);
                    }
                };

                ws.onclose = (event) => {
                    setConnected(false);
                    if (wsRef.current === ws) wsRef.current = null;

                    const normalCloseCodes = [1000, 1001];
                    const shouldReconnect = !normalCloseCodes.includes(event.code) && reconnectAttemptCount < MAX_RECONNECT_ATTEMPTS;

                    if (shouldReconnect) {
                        const delay = 3000 + (reconnectAttemptCount * 2000);
                        showNotification(`Yenid…ôn baƒülanƒ±lƒ±r... (${reconnectAttemptCount + 1}/${MAX_RECONNECT_ATTEMPTS})`, 'warning');
                        setReconnectAttemptCount(prev => prev + 1);
                        if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);
                        reconnectTimerRef.current = setTimeout(() => {
                            connectToServer();
                        }, delay);
                    } else if (reconnectAttemptCount >= MAX_RECONNECT_ATTEMPTS) {
                        showNotification('Baƒülantƒ± uƒüursuz. S…ôhif…ôni yenil…ôyin.', 'error');
                    }
                };

                ws.onerror = (error) => {
                    console.error('WebSocket Error:', error);
                };

                ws.onmessage = (e) => {
                    try {
                        const data = JSON.parse(e.data);
                        handleServerMessage(data);
                    } catch (err) { }
                };
            };

            const sendMessage = (msg) => {
                const ws = wsRef.current;
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    if (!ws || ws.readyState === WebSocket.CLOSED) connectToServer();
                    showNotification('Baƒülantƒ± g√∂zl…ônilir...', 'warning');
                    return false;
                }
                try {
                    ws.send(JSON.stringify(msg));
                    return true;
                } catch (error) {
                    showNotification('Mesaj g√∂nd…ôril…ô bilm…ôdi', 'error');
                    return false;
                }
            };

            const handleServerMessage = (data) => {
                switch (data.type) {
                    case 'roomCreated':
                        setRoomCode(data.roomCode);
                        showNotification('Otaq yaradƒ±ldƒ±: ' + data.roomCode, 'success');
                        break;

                    case 'gameUpdate':
                        if (data.gameState && data.gameState.board) {
                            setGameState(prev => ({ ...prev, ...data.gameState }));
                            setSelectedTileIndex(null);
                            setValidMoves([]);
                        }
                        break;

                    case 'error':
                        showNotification(data.message || 'X…ôta ba≈ü verdi', 'error');
                        if (data.message && (data.message.includes('not found') || data.message.includes('tapƒ±lmadƒ±'))) {
                            localStorage.removeItem(LOCAL_STORAGE_ROOM);
                            localStorage.removeItem(LOCAL_STORAGE_PLAYER);
                            if (screen === 'loading') setTimeout(() => setScreen('lobby'), 500);
                        }
                        setSearching(false);
                        if (screen === 'game' && data.fatal) {
                            resetGameClientState();
                            setScreen('lobby');
                        }
                        break;

                    case 'gameEnd':
                        setEndInfo({
                            winnerName: data.winnerName,
                            isWinner: data.isWinner,
                            eloChange: data.eloChange,
                            message: data.message
                        });
                        setScreen('end');
                        setTimeout(() => {
                            resetGameClientState();
                            setScreen('lobby');
                        }, 5000);
                        break;

                    case 'matchFound':
                        showNotification(`R…ôqib Tapƒ±ldƒ±!`, 'success');
                        setSearching(false);
                        setOpponent(data.opponent || null);
                        if (searchTimerRef.current) {
                            clearInterval(searchTimerRef.current);
                            searchTimerRef.current = null;
                        }
                        setSearchTime(0);
                        break;

                    case 'reconnectSuccess':
                    case 'gameStart':
                        setGameState(data.gameState);
                        setScreen('game');

                        // Opponent info extracted from game state if needed
                        const oppId = Object.keys(data.gameState.players).find(id => id !== data.gameState.playerId);
                        if (oppId) setOpponent(data.gameState.players[oppId]);

                        setSelectedTileIndex(null);
                        setValidMoves([]);
                        setSearching(false);

                        if (data.gameState.roomCode && data.gameState.playerId) {
                            localStorage.setItem(LOCAL_STORAGE_ROOM, data.gameState.roomCode);
                            localStorage.setItem(LOCAL_STORAGE_PLAYER, data.gameState.playerId);
                        }

                        if (searchTimerRef.current) {
                            clearInterval(searchTimerRef.current);
                            searchTimerRef.current = null;
                        }
                        setSearchTime(0);
                        showNotification(data.type === 'reconnectSuccess' ? 'Oyuna Davam Edildi!' : 'Oyun Ba≈üladƒ±!', 'success');
                        break;

                    case 'opponentDisconnected':
                        showNotification('R…ôqib baƒülantƒ±sƒ± k…ôsildi...', 'warning');
                        break;

                    case 'opponentReconnected':
                        showNotification('R…ôqib yenid…ôn qo≈üuldu!', 'info');
                        break;
                }
            };

            useEffect(() => {
                const startApp = async () => {
                    await initializeTelegramAuth();
                    connectToServer();
                };
                initialLoadTimeoutRef.current = setTimeout(() => {
                    if (screen === 'loading') {
                        setScreen('lobby');
                    }
                }, 10000);

                connectionCheckRef.current = setInterval(() => {
                    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN && screen === 'game') {
                        sendMessage({ type: 'ping' });
                    }
                }, 30000);

                startApp();

                return () => {
                    if (wsRef.current) wsRef.current.close();
                    if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);
                    if (connectionCheckRef.current) clearInterval(connectionCheckRef.current);
                    if (initialLoadTimeoutRef.current) clearTimeout(initialLoadTimeoutRef.current);
                };
            }, []);

            const initializeTelegramAuth = async () => {
                try {
                    let user = { username: 'Guest', telegramId: 'guest_' + Date.now(), isGuest: true };
                    if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
                        const tgu = tg.initDataUnsafe.user;
                        user = {
                            telegramId: tgu.id.toString(),
                            username: tgu.username || tgu.first_name,
                            firstName: tgu.first_name,
                            photoUrl: tgu.photo_url,
                            isGuest: false
                        };
                    }

                    const response = await fetch(`${API_URL}/api/auth/telegram`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(user)
                    });
                    const data = await response.json();

                    if (data.success) {
                        setPlayerData({ ...data.player, isGuest: user.isGuest, photoUrl: user.photoUrl });
                    } else {
                        setPlayerData(user);
                    }
                } catch (error) {
                    setPlayerData({ isGuest: true, username: 'Qonaq' });
                }
                finally {
                    setTimeout(() => setScreen('lobby'), 100);
                }
            };

            const loadLeaderboard = async () => {
                try {
                    const response = await fetch(`${API_URL}/api/leaderboard`);
                    const data = await response.json();
                    if (data.success) {
                        setLeaderboard(data.leaderboard);
                    }
                } catch (error) { }
            };

            // --- TOUCH/PINCH ZOOM HANDLERS ---
            const handleTouchStart = useCallback((e) => {
                if (e.target.closest('.valid-move-indicator')) return;

                if (e.touches.length === 2) {
                    e.preventDefault();
                    const d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    setPinchStart({ distance: d });
                } else if (e.touches.length === 1) {
                    e.preventDefault();
                    setIsDragging(true);
                    setDragStart({ x: e.touches[0].clientX - boardPosition.x, y: e.touches[0].clientY - boardPosition.y });

                    const currentTime = Date.now();
                    if (currentTime - lastTouchTimeRef.current < 300) {
                        setBoardZoom(1);
                        setBoardPosition({ x: 0, y: 0 });
                    }
                    lastTouchTimeRef.current = currentTime;
                }
            }, [boardPosition]);

            const handleTouchMove = useCallback((e) => {
                if (e.touches.length === 2 && pinchStart.distance > 0) {
                    e.preventDefault();
                    const d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const scaleChange = d / pinchStart.distance;
                    setBoardZoom(prev => Math.min(Math.max(prev * scaleChange, 0.5), 3));
                    setPinchStart({ distance: d });
                    if (showZoomHint) setShowZoomHint(false);
                } else if (e.touches.length === 1 && isDragging) {
                    e.preventDefault();
                    setBoardPosition({ x: e.touches[0].clientX - dragStart.x, y: e.touches[0].clientY - dragStart.y });
                }
            }, [isDragging, dragStart, pinchStart, showZoomHint]);

            const handleTouchEnd = useCallback((e) => {
                setIsDragging(false);
                setPinchStart({ distance: 0 });
                if (zoomHintTimeoutRef.current) clearTimeout(zoomHintTimeoutRef.current);
                zoomHintTimeoutRef.current = setTimeout(() => {
                    if (screen === 'game' && boardZoom === 1) setShowZoomHint(true);
                }, 5000);
            }, [screen, boardZoom]);

            const handleMouseDown = useCallback((e) => {
                if (e.button !== 0) return;
                e.preventDefault();
                setIsDragging(true);
                setDragStart({ x: e.clientX - boardPosition.x, y: e.clientY - boardPosition.y });
            }, [boardPosition]);

            const handleMouseMove = useCallback((e) => {
                if (isDragging) {
                    e.preventDefault();
                    setBoardPosition({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y });
                }
            }, [isDragging, dragStart]);

            const handleMouseUp = useCallback(() => setIsDragging(false), []);

            const handleWheel = useCallback((e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                setBoardZoom(prev => Math.min(Math.max(prev * zoomFactor, 0.5), 3));
                if (showZoomHint) setShowZoomHint(false);
            }, [showZoomHint]);

            useEffect(() => {
                const el = boardContainerRef.current;
                if (el) {
                    el.addEventListener('touchstart', handleTouchStart, { passive: false });
                    el.addEventListener('touchmove', handleTouchMove, { passive: false });
                    el.addEventListener('touchend', handleTouchEnd);
                    el.addEventListener('mousedown', handleMouseDown);
                    el.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    el.addEventListener('wheel', handleWheel, { passive: false });
                    return () => {
                        el.removeEventListener('touchstart', handleTouchStart);
                        el.removeEventListener('touchmove', handleTouchMove);
                        el.removeEventListener('touchend', handleTouchEnd);
                        el.removeEventListener('mousedown', handleMouseDown);
                        el.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                        el.removeEventListener('wheel', handleWheel);
                    };
                }
            }, [handleTouchStart, handleTouchMove, handleTouchEnd, handleMouseDown, handleMouseMove, handleMouseUp, handleWheel]);

            const myPlayerId = gameState?.playerId;
            const isMyTurn = gameState?.currentPlayer === myPlayerId;
            const myHand = gameState?.players?.[myPlayerId]?.hand || [];
            const marketSize = gameState?.market?.length || 0;

            const opponentHandCount = useMemo(() => {
                if (!gameState || !gameState.players) return 0;
                const opponentId = Object.keys(gameState.players).find(id => id !== myPlayerId);
                return gameState.players[opponentId]?.handCount || gameState.players[opponentId]?.hand?.length || 0;
            }, [gameState, myPlayerId]);

            const renderBoardTiles = useMemo(() => {
                if (!gameState?.board || gameState.board.length === 0) return [];
                const tiles = [];
                const TILE_WIDTH = 60;
                let rightX = 0;

                // Straight line rendering for simplicity and robustness
                gameState.board.forEach((tile, i) => {
                    tiles.push({ tile, position: { x: rightX, y: 0 }, rotation: 0 });
                    rightX += TILE_WIDTH;
                });

                // Center
                const offsetX = -(rightX - TILE_WIDTH) / 2;
                return tiles.map(t => ({ ...t, position: { x: t.position.x + offsetX, y: t.position.y } }));
            }, [gameState?.board]);

            const calculateValidMoves = (tile) => {
                if (!gameState || gameState.board.length === 0) return ['start'];
                const board = gameState.board;
                // Simple assumption: board is array of arrays [[1,2], [2,3]]
                const leftEnd = board[0].tile?.[0] ?? board[0][0];
                const rightEnd = board[board.length - 1].tile?.[1] ?? board[board.length - 1][1];

                const moves = [];
                if (tile[0] === leftEnd || tile[1] === leftEnd) moves.push('left');
                if (tile[0] === rightEnd || tile[1] === rightEnd) moves.push('right');
                return moves;
            };

            const handleTileClick = (index) => {
                if (!isMyTurn) return showNotification('N√∂vb…ôniz deyil!', 'warning');
                const tile = myHand[index];
                if (selectedTileIndex === index) {
                    setSelectedTileIndex(null);
                    setValidMoves([]);
                    return;
                }
                const moves = calculateValidMoves(tile);
                if (moves.length > 0) {
                    setSelectedTileIndex(index);
                    setValidMoves(moves);
                    showNotification('Da≈ü se√ßildi. M√∂vqe se√ßin', 'info');
                } else {
                    showNotification('Bu da≈üla oynaya bilm…ôzsiniz', 'warning');
                }
            };

            const playTile = (position) => {
                if (selectedTileIndex === null) return;
                sendMessage({ type: 'playTile', tileIndex: selectedTileIndex, position });
            };

            const drawFromMarket = () => {
                if (!isMyTurn) return showNotification('N√∂vb…ôniz deyil!', 'warning');
                if (marketSize === 0) return showNotification('Bazar bo≈üdur!', 'warning');
                if (gameState.board.length > 0 && myHand.some(tile => calculateValidMoves(tile).length > 0)) {
                    showNotification('Elind…ô oynaya bil…ôc…ôyiniz da≈ü var!', 'error');
                    return;
                }
                sendMessage({ type: 'drawFromMarket' });
            };

            const leaveGameClient = () => {
                if (confirm('Oyundan √ßƒ±xmaq ist…ôdiyiniz…ô …ôminsiniz? ELO itir…ôc…ôksiniz.')) {
                    sendMessage({ type: 'leaveGame' });
                    resetGameClientState();
                    setScreen('lobby');
                }
            };

            if (screen === 'loading') return <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 flex items-center justify-center"><div className="loading-spinner"></div></div>;

            if (screen === 'searching') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 flex items-center justify-center p-6">
                        <div className="bg-white/10 backdrop-blur-xl rounded-3xl p-8 shadow-2xl border border-white/20 text-center w-full max-w-md">
                            {opponent ? (
                                <div className="animate-pulse">
                                    <h2 className="text-3xl font-bold text-green-400 mb-2">R∆èQƒ∞B TAPILDI!</h2>
                                    <img src={opponent.photoUrl} className="w-24 h-24 rounded-full mx-auto my-4 border-4 border-green-500" />
                                    <div className="text-white text-xl font-bold">{opponent.username}</div>
                                </div>
                            ) : (
                                <div>
                                    <div className="w-24 h-24 rounded-full mx-auto mb-4 border-4 border-yellow-400 animate-spin flex items-center justify-center"><span className="text-4xl">üéØ</span></div>
                                    <h3 className="text-white text-2xl font-bold mb-4">Axtarƒ±lƒ±r...</h3>
                                    <button onClick={() => { setSearching(false); setScreen('lobby'); sendMessage({ type: 'cancelSearch' }); }} className="bg-red-600 text-white font-bold py-3 px-8 rounded-xl">L…ôƒüv Et</button>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (screen === 'lobby') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-900 via-emerald-800 to-teal-900 flex flex-col items-center justify-center p-4">
                        {notification && <Toast message={notification.message} type={notification.type} />}
                        <div className="text-center mb-8">
                            <h1 className="text-4xl font-black text-white drop-shadow-lg mb-2">üéØ DOMINO <span className="text-yellow-400">101</span> üèÜ</h1>
                        </div>
                        <div className="w-full max-w-md bg-black/40 backdrop-blur-md rounded-2xl p-6 shadow-2xl border border-white/10">
                            {playerData && (
                                <div className="mb-6 text-center flex flex-col items-center">
                                    {playerData.photoUrl && <img src={playerData.photoUrl} className="w-20 h-20 rounded-full border-4 border-yellow-400 mb-4 shadow-lg" />}
                                    <h2 className="text-white text-2xl font-bold mb-2">{playerData.username}</h2>
                                    {!playerData.isGuest && <div className="text-blue-300 font-bold">{playerData.elo} ELO</div>}
                                </div>
                            )}
                            <button onClick={() => {
                                setScreen('searching'); setSearching(true);
                                sendMessage({ type: 'findMatch', telegramId: playerData.telegramId, username: playerData.username });
                            }} className="w-full bg-gradient-to-r from-yellow-500 to-amber-600 text-white font-bold py-4 rounded-xl shadow-lg mb-4 flex items-center justify-center gap-2">
                                ‚öîÔ∏è OYUN AXTAR
                            </button>
                            <div className="grid grid-cols-2 gap-3 mb-4">
                                <button onClick={() => sendMessage({ type: 'createRoom', telegramId: playerData.telegramId, username: playerData.username })} className="bg-white/10 text-white py-3 rounded-xl font-bold">üè† OTAQ YARAT</button>
                                <div className="relative">
                                    <input value={joinCode} onChange={e => setJoinCode(e.target.value.toUpperCase())} placeholder="KOD" className="w-full h-full bg-black/30 border border-white/10 rounded-xl px-2 text-center text-white" />
                                    <button onClick={() => sendMessage({ type: 'joinRoom', roomCode: joinCode, telegramId: playerData.telegramId, username: playerData.username })} className="absolute right-1 top-1 bottom-1 bg-yellow-500 text-white px-3 rounded-lg">‚ûî</button>
                                </div>
                            </div>
                            {roomCode && <div className="mt-4 p-4 bg-green-500/20 rounded-xl text-center"><div className="text-3xl font-mono text-white font-bold">{roomCode}</div><div className="text-xs text-gray-300">Dostunuz g√∂zl…ônilir...</div></div>}
                            <div className="flex justify-center"><button onClick={() => { setScreen('leaderboard'); loadLeaderboard(); }} className="px-4 py-2 bg-purple-600 text-white rounded-lg font-bold">üèÜ Skor Tablosu</button></div>
                        </div>
                    </div>
                );
            }

            if (screen === 'leaderboard') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 flex flex-col items-center justify-center p-4">
                        <h1 className="text-3xl text-white font-bold mb-6">üèÜ Liderl…ôr</h1>
                        <button onClick={() => setScreen('lobby')} className="mb-4 text-white bg-slate-700 px-4 py-2 rounded">Geri</button>
                        <div className="w-full max-w-lg space-y-2">
                            {leaderboard.map((p, i) => (
                                <div key={i} className="bg-black/40 p-3 rounded flex items-center gap-4 text-white">
                                    <div className="font-bold text-yellow-400">#{i + 1}</div>
                                    <img src={p.photoUrl} className="w-8 h-8 rounded-full" />
                                    <div className="flex-1">{p.username}</div>
                                    <div className="font-mono text-blue-300">{p.elo}</div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            }

            if (screen === 'game' && gameState) {
                return (
                    <div className="fixed inset-0 flex flex-col h-full w-full bg-table-base">
                        {notification && <Toast message={notification.message} type={notification.type} />}
                        <div className="h-16 bg-gradient-to-b from-black/60 to-transparent flex items-center justify-between px-4 z-20">
                            <div className="flex items-center gap-3">
                                {opponent && <img src={opponent.photoUrl} className="w-10 h-10 rounded-full border-2 border-yellow-400" />}
                                <div><div className="text-white text-sm font-bold">{opponent?.username || 'R…ôqib'}</div></div>
                            </div>
                            <div className={`px-4 py-1.5 rounded-full text-xs font-bold ${isMyTurn ? 'bg-yellow-500 text-black animate-pulse' : 'bg-black/40 text-gray-400'}`}>
                                {isMyTurn ? 'Sƒ∞Zƒ∞N N√ñVB∆èNƒ∞Z' : 'R…ôqib Oynayƒ±r...'}
                            </div>
                        </div>

                        <div className="flex-1 relative overflow-hidden w-full">
                            <div ref={boardContainerRef} className="domino-board-container">
                                {showZoomHint && boardZoom === 1 && <div className="zoom-hint">üëÜ ƒ∞ki barmaqla b√∂y√ºt / ki√ßilt</div>}
                                <div ref={boardInnerRef} className="domino-board-inner" style={{ transform: `translate(${boardPosition.x}px, ${boardPosition.y}px) scale(${boardZoom})` }}>
                                    {renderBoardTiles.map(({ tile, position }, i) => (
                                        <div key={i} className="board-tile" style={{ left: position.x, top: position.y, transform: 'translate(-50%, -50%)' }}>
                                            <DominoTile values={tile} disabled={true} isBoardTile={true} />
                                        </div>
                                    ))}
                                    {validMoves.includes('left') && <div className="valid-move-indicator" style={{ position: 'absolute', left: renderBoardTiles[0]?.position.x - 30, top: renderBoardTiles[0]?.position.y, width: 60, height: 32, transform: 'translate(-50%, -50%)' }} onClick={() => playTile('left')}><div className="text-yellow-400 text-xs font-bold">SOL</div></div>}
                                    {validMoves.includes('right') && <div className="valid-move-indicator" style={{ position: 'absolute', left: renderBoardTiles[renderBoardTiles.length - 1]?.position.x + 30, top: renderBoardTiles[renderBoardTiles.length - 1]?.position.y, width: 60, height: 32, transform: 'translate(-50%, -50%)' }} onClick={() => playTile('right')}><div className="text-yellow-400 text-xs font-bold">SAƒû</div></div>}
                                    {validMoves.includes('start') && <div className="valid-move-indicator" style={{ position: 'absolute', left: '50%', top: '50%', width: 65, height: 35, transform: 'translate(-50%, -50%)' }} onClick={() => playTile('start')}><div className="text-yellow-400 font-bold text-sm">BA≈ûLA</div></div>}
                                </div>
                            </div>
                        </div>

                        <div className="bg-gradient-to-t from-black/90 via-table-dark to-transparent pb-3 pt-2 z-20">
                            <div className="flex justify-between items-center px-4 mb-2">
                                <span className="text-white text-xs font-bold opacity-70">üé¥ ∆èLƒ∞Nƒ∞Z ({myHand.length})</span>
                                <button onClick={leaveGameClient} className="bg-red-600/80 hover:bg-red-600 text-white text-xs px-4 py-2 rounded-full font-bold">üö™ √áƒ±x</button>
                            </div>
                            <div className="hand-tiles-container hide-scrollbar">
                                {myHand.map((tile, index) => (
                                    <div key={index} className="hand-tile-wrapper">
                                        <DominoTile values={tile} onClick={() => handleTileClick(index)} disabled={!isMyTurn} isSelected={selectedTileIndex === index} />
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            }

            if (screen === 'end' && endInfo) {
                return (
                    <div className="min-h-screen bg-black/95 flex items-center justify-center p-6 text-center">
                        <div>
                            <h1 className={`text-4xl font-bold mb-4 ${endInfo.isWinner ? 'text-green-400' : 'text-red-400'}`}>{endInfo.isWinner ? 'QAZANDINIZ!' : 'UDUZDUNUZ'}</h1>
                            <p className="text-white mb-6">{endInfo.message}</p>
                            <div className="text-3xl font-bold text-white mb-8">{endInfo.eloChange > 0 ? '+' : ''}{endInfo.eloChange} ELO</div>
                            <button onClick={() => { resetGameClientState(); setScreen('lobby'); }} className="bg-white text-black px-8 py-3 rounded-full font-bold">Ana Menyu</button>
                        </div>
                    </div>
                );
            }
            return null;
        };

        const setAppHeight = () => document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`);
        window.addEventListener('resize', setAppHeight);
        setAppHeight();

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DominoGame />);
    </script>
</body>

</html>
