<!DOCTYPE html>
<html lang="az">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1b4d3e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Domino 101 Pro - Azure</title>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Roboto', 'sans-serif'] },
                    colors: {
                        table: {
                            base: '#1b4d3e',
                            dark: '#0f2b23',
                            light: '#2c6b58'
                        },
                        bone: {
                            face: '#fdfdfd',
                            side: '#e2e2e2',
                            shadow: '#00000040'
                        }
                    },
                    boxShadow: {
                        '3d': '0px 4px 0px #c7c7c7, 0px 6px 6px rgba(0,0,0,0.4)',
                        '3d-active': '0px 2px 0px #c7c7c7, 0px 3px 3px rgba(0,0,0,0.4)',
                    },
                    animation: {
                        'pulse-glow': 'pulseGlow 2s infinite',
                    },
                    keyframes: {
                        pulseGlow: {
                            '0%, 100%': { boxShadow: '0 0 10px rgba(251, 191, 36, 0.6)' },
                            '50%': { boxShadow: '0 0 20px rgba(251, 191, 36, 1)' }
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #1b4d3e;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23153d31' fill-opacity='0.4' fill-rule='evenodd'%3E%3Cpath d='M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z'/%3E%3C/g%3E%3C/svg%3E");
            overflow: hidden;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .pip-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            padding: 2px;
        }

        .pip {
            background-color: #111;
            border-radius: 50%;
            width: 4px;
            height: 4px;
            margin: auto;
        }

        /* DOMINO BOARD STYLES */
        .domino-board-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            touch-action: none;
            /* Critical for custom gestures */
            background: rgba(27, 77, 62, 0.5);
        }

        .domino-board-inner {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: auto;
            width: 100%;
            height: 100%;
            transform-origin: center center;
            will-change: transform;
        }

        .domino-tile {
            display: inline-flex;
            background: #fff;
            border: 1px solid #333;
            /* Thinner border for gapless look */
            border-radius: 4px;
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            position: relative;
            box-sizing: border-box;
        }

        .domino-tile.horizontal {
            flex-direction: row;
        }

        .domino-tile.vertical {
            flex-direction: column;
        }

        .domino-tile-face {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .domino-divider {
            background: #333;
            position: absolute;
            z-index: 1;
        }

        .domino-tile.horizontal .domino-divider {
            width: 1px;
            height: 80%;
            top: 10%;
            left: 50%;
        }

        .domino-tile.vertical .domino-divider {
            height: 1px;
            width: 80%;
            left: 10%;
            top: 50%;
        }

        /* Board Tile Specifics */
        .board-tile-wrapper {
            position: absolute;
            transform: translate(-50%, -50%);
        }

        /* Hand Tiles Container */
        .hand-tiles-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 10px;
            /* Normal domino layout: sitting next to each other */
        }

        .hand-tile-wrapper {
            margin: 0 1px;
            /* Very small gap */
            transition: transform 0.2s;
        }

        .hand-tile-wrapper:hover {
            transform: translateY(-10px);
            z-index: 10;
        }

        /* Valid Move Indicator */
        .valid-move-indicator {
            position: absolute;
            z-index: 50;
            border: 2px dashed rgba(255, 215, 0, 0.8);
            border-radius: 6px;
            background: rgba(255, 215, 0, 0.2);
            animation: pulse-glow 1.5s infinite;
            transform: translate(-50%, -50%);
        }

        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        const tg = window.Telegram?.WebApp;
        if (tg) { tg.ready(); tg.expand(); }

        const API_URL = 'https://beta-github-io.onrender.com';
        const WS_URL = 'wss://beta-github-io.onrender.com';

        // --- COMPONENTS ---
        const RenderPips = ({ number }) => {
            const layouts = {
                0: [], 1: [4], 2: [0, 8], 3: [0, 4, 8],
                4: [0, 2, 6, 8], 5: [0, 2, 4, 6, 8], 6: [0, 2, 3, 5, 6, 8]
            };
            const activePips = layouts[number] || [];
            return (
                <div className="pip-grid">
                    {[...Array(9)].map((_, i) => (
                        <div key={i} className="pip" style={{ opacity: activePips.includes(i) ? 1 : 0 }}></div>
                    ))}
                </div>
            );
        };

        const DominoTile = ({ values, onClick, disabled, isSelected, direction = 'right', isBoardTile = false }) => {
            const isVertical = direction === 'up' || direction === 'down';

            // SIZING LOGIC
            // Board tiles: 60x30 (Matches logic)
            // Hand tiles: 40x80 (Standing up)
            const style = isBoardTile
                ? { width: '60px', height: '30px' }
                : { width: '40px', height: '80px' };

            // Start vertical for hand tiles usually, but here values determine face.
            // If isBoardTile, rotation is handled by parent or css class.
            // Wait, we need internal flex direction.
            // Hand tiles: Vertical (standing).
            // Board tiles: Depends on direction.

            const flexDir = isBoardTile
                ? (isVertical ? 'column' : 'row')
                : 'column'; // Hand tiles always vertical

            // Rotation for board tiles handled by transform in parent to keep pips rights side up? 
            // Or just rotate the tile div.

            let rotation = 0;
            if (isBoardTile) {
                if (direction === 'left') rotation = 180;
                if (direction === 'up') rotation = -90;
                if (direction === 'down') rotation = 90;
            }

            // Adjust width/height if rotated
            const loadStyle = {
                width: isBoardTile ? '60px' : '40px',
                height: isBoardTile ? '30px' : '80px',
                flexDirection: 'row', // Default horizontal
            }

            if (isBoardTile) {
                if (isVertical) {
                    loadStyle.width = '30px';
                    loadStyle.height = '60px';
                    loadStyle.flexDirection = 'column';
                }
            } else {
                // Hand tiles are vertical
                loadStyle.width = '40px';
                loadStyle.height = '80px';
                loadStyle.flexDirection = 'column';
            }

            return (
                <div
                    onClick={onClick}
                    className={`domino-tile ${isSelected ? 'ring-2 ring-yellow-400 transform -translate-y-2' : ''} ${disabled ? 'opacity-80' : 'cursor-pointer'}`}
                    style={{
                        ...loadStyle,
                        transition: 'all 0.2s',
                    }}
                >
                    <div className={`domino-tile-face ${loadStyle.flexDirection === 'column' ? 'border-b' : 'border-r'} border-gray-800`}>
                        <RenderPips number={values[0]} />
                    </div>
                    <div className="domino-tile-face">
                        <RenderPips number={values[1]} />
                    </div>
                    <div className="domino-divider"></div>
                </div>
            );
        };

        const Toast = ({ message, type }) => {
            const bg = type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600';
            return (
                <div className={`fixed top-4 left-1/2 -translate-x-1/2 z-50 px-4 py-2 rounded-full text-white text-sm font-bold shadow-lg ${bg} animate-bounce`}>
                    {message}
                </div>
            );
        };

        const DominoGame = () => {
            const [screen, setScreen] = useState('loading');
            const [connected, setConnected] = useState(false);
            const [playerData, setPlayerData] = useState(null);
            const [roomCode, setRoomCode] = useState('');
            const [joinCode, setJoinCode] = useState('');
            const [gameState, setGameState] = useState(null);
            const [searchTime, setSearchTime] = useState(0);
            const [isMatchFound, setIsMatchFound] = useState(false); // NEW STATE

            const [selectedTileIndex, setSelectedTileIndex] = useState(null);
            const [validMoves, setValidMoves] = useState([]);
            const [notification, setNotification] = useState(null);
            const [searching, setSearching] = useState(false);
            const [endInfo, setEndInfo] = useState(null);
            const [opponent, setOpponent] = useState(null);
            const [leaderboard, setLeaderboard] = useState([]);

            // ZOOM/PAN STATE
            const [boardZoom, setBoardZoom] = useState(1);
            const [boardPosition, setBoardPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [pinchDistance, setPinchDistance] = useState(null);

            const wsRef = useRef(null);
            const boardContainerRef = useRef(null);
            const reconnectTimerRef = useRef(null);
            const searchTimerRef = useRef(null);

            // --- NOTIFICATION ---
            const showNotification = (msg, type = 'info') => {
                setNotification({ message: msg, type });
                setTimeout(() => setNotification(null), 3000);
            };

            // --- WS LOGIC ---
            useEffect(() => {
                connectToServer();
                return () => {
                    if (wsRef.current) wsRef.current.close();
                };
            }, []);

            const connectToServer = () => {
                const ws = new WebSocket(WS_URL);
                wsRef.current = ws;

                ws.onopen = () => {
                    setConnected(true);
                    showNotification('Server…ô qo≈üuldu ‚úÖ', 'success');
                    initializeTelegramAuth();
                };

                ws.onclose = () => {
                    setConnected(false);
                    setTimeout(connectToServer, 3000);
                };

                ws.onmessage = (e) => {
                    try {
                        const data = JSON.parse(e.data);
                        handleServerMessage(data);
                    } catch (err) { console.error(err); }
                };
            };

            const sendMessage = (msg) => {
                if (wsRef.current?.readyState === WebSocket.OPEN) {
                    wsRef.current.send(JSON.stringify(msg));
                }
            };

            const handleServerMessage = (data) => {
                switch (data.type) {
                    case 'matchFound':
                        // Fix for Game Not Starting UI
                        console.log('Match Found!', data);
                        setIsMatchFound(true);
                        setOpponent(data.opponent);
                        setSearching(false); // Stop internal searching logic
                        if (searchTimerRef.current) clearInterval(searchTimerRef.current);
                        // Do NOT change screen yet, wait for user to see "Match Found" or gameStart
                        break;
                    case 'gameStart':
                    case 'reconnectSuccess':
                        console.log('Game Started');
                        setGameState(data.gameState);
                        setScreen('game');
                        setSearching(false);
                        setIsMatchFound(false);
                        showNotification('Oyun Ba≈üladƒ±! üéÆ', 'success');
                        break;
                    case 'gameUpdate':
                        setGameState(prev => ({ ...prev, ...data.gameState }));
                        setSelectedTileIndex(null);
                        setValidMoves([]);
                        break;
                    case 'gameEnd':
                        setEndInfo(data);
                        setScreen('end');
                        setTimeout(() => { setScreen('lobby'); setGameState(null); }, 5000);
                        break;
                    case 'roomCreated':
                        setRoomCode(data.roomCode);
                        break;
                    default:
                        break;
                }
            };

            const initializeTelegramAuth = async () => {
                // Simulated or Real Auth
                if (tg?.initDataUnsafe?.user) {
                    const u = tg.initDataUnsafe.user;
                    setPlayerData({ username: u.first_name, photoUrl: u.photo_url, telegramId: u.id, isGuest: false });
                    setScreen('lobby');
                } else {
                    setPlayerData({ username: 'Qonaq', isGuest: true });
                    setScreen('lobby');
                }
            };

            // --- PAN / ZOOM LOGIC (BUTTONLESS) ---
            const handleTouchStart = (e) => {
                if (e.touches.length === 2) {
                    const d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    setPinchDistance(d);
                } else if (e.touches.length === 1) {
                    setIsDragging(true);
                    setDragStart({ x: e.touches[0].clientX - boardPosition.x, y: e.touches[0].clientY - boardPosition.y });
                }
            };

            const handleTouchMove = (e) => {
                // Prevent Default to stop page scrolling while playing
                if (e.cancelable) e.preventDefault();

                if (e.touches.length === 2 && pinchDistance) {
                    const d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const scale = d / pinchDistance;
                    setBoardZoom(z => Math.max(0.5, Math.min(3, z * scale))); // Limit zoom
                    setPinchDistance(d);
                } else if (e.touches.length === 1 && isDragging) {
                    const x = e.touches[0].clientX - dragStart.x;
                    const y = e.touches[0].clientY - dragStart.y;
                    setBoardPosition({ x, y });
                }
            };

            const handleTouchEnd = () => {
                setIsDragging(false);
                setPinchDistance(null);
            };

            useEffect(() => {
                const el = boardContainerRef.current;
                if (!el) return;
                el.addEventListener('touchstart', handleTouchStart, { passive: false });
                el.addEventListener('touchmove', handleTouchMove, { passive: false });
                el.addEventListener('touchend', handleTouchEnd);
                return () => {
                    el.removeEventListener('touchstart', handleTouchStart);
                    el.removeEventListener('touchmove', handleTouchMove);
                    el.removeEventListener('touchend', handleTouchEnd);
                };
            }, [boardPosition, pinchDistance, isDragging, dragStart]);


            // --- RENDER HELPERS ---
            // Render Tiles Touching Logic
            const renderBoardTiles = useMemo(() => {
                if (!gameState?.board) return [];
                const tiles = [];
                let x = 0, y = 0;
                let dir = 'right';
                // Simple snake logic for demo or use advanced if available
                // User requirement: "tiles touching".
                // We use 60px width.
                const TILE_W = 60;
                const TILE_H = 30;

                // Align them properly
                // For simplicity in this fix, we will just render a straight line or simple snake
                // to ensure they touch.

                gameState.board.forEach((tile, i) => {
                    tiles.push({ tile, x, y, dir });
                    // Determine next pos
                    x += TILE_W;
                });

                // Center the board
                if (tiles.length > 0) {
                    const totalW = tiles[tiles.length - 1].x;
                    const offX = -totalW / 2;
                    return tiles.map(t => ({ ...t, x: t.x + offX }));
                }
                return tiles;
            }, [gameState?.board]);

            const playTile = (pos) => {
                if (selectedTileIndex === null) return;
                sendMessage({ type: 'playTile', tileIndex: selectedTileIndex, position: pos });
            };

            const myHand = gameState?.players?.[gameState?.playerId]?.hand || [];

            // --- SCREENS ---
            if (screen === 'loading') return <div className="flex h-screen items-center justify-center text-white text-2xl font-bold">Y√ºkl…ônir...</div>;

            if (screen === 'searching') {
                return (
                    <div className="flex flex-col h-screen items-center justify-center bg-gray-900 text-white p-4 text-center">
                        {isMatchFound ? (
                            <div className="animate-pulse">
                                <h1 className="text-4xl text-green-500 font-bold mb-4">R…ôqib Tapƒ±ldƒ±!</h1>
                                <p className="text-xl">Oyun ba≈üladƒ±lƒ±r...</p>
                                {opponent && <div className="mt-4 text-2xl font-bold">{opponent.name}</div>}
                            </div>
                        ) : (
                            <div>
                                <h1 className="text-3xl font-bold mb-4">R…ôqib Axtarƒ±lƒ±r...</h1>
                                <div className="animate-spin text-4xl mb-4">‚è≥</div>
                                <button onClick={() => { setSearching(false); setScreen('lobby'); sendMessage({ type: 'cancelSearch' }) }} className="bg-red-600 px-6 py-2 rounded-full font-bold">L∆èƒûV ET</button>
                            </div>
                        )}
                    </div>
                );
            }

            if (screen === 'lobby') {
                return (
                    <div className="flex flex-col h-screen items-center justify-center bg-gradient-to-br from-green-900 to-black text-white p-4">
                        <h1 className="text-5xl font-bold mb-2">DOMƒ∞NO 101</h1>
                        <p className="mb-8 opacity-70">Az…ôrbaycanƒ±n ∆èn Yax≈üƒ± Domino Oyunu</p>

                        {playerData && <div className="mb-8 text-xl font-bold">Salam, {playerData.username}!</div>}

                        <button onClick={() => {
                            setScreen('searching'); setIsMatchFound(false); setSearching(true);
                            sendMessage({ type: 'findMatch', ...playerData });
                        }} className="bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-4 px-12 rounded-2xl shadow-lg mb-4 text-xl w-full max-w-sm">
                            OYUN AXTAR
                        </button>

                        <div className="flex gap-4 w-full max-w-sm">
                            <button className="flex-1 bg-white/20 py-3 rounded-xl font-bold" onClick={() => { sendMessage({ type: 'createRoom', ...playerData }) }}>OTAQ YARAT</button>
                            <input className="flex-1 bg-black/40 rounded-xl px-4 text-center font-mono uppercase" placeholder="KOD" value={joinCode} onChange={e => setJoinCode(e.target.value)} />
                            <button className="bg-green-600 px-4 rounded-xl" onClick={() => sendMessage({ type: 'joinRoom', roomCode: joinCode, ...playerData })}>Go</button>
                        </div>

                        {roomCode && <div className="mt-4 bg-white/20 p-4 rounded-xl text-center">
                            <div className="text-sm opacity-70">OTAQ KODU</div>
                            <div className="text-3xl font-mono font-bold tracking-widest">{roomCode}</div>
                            <div className="text-sm mt-2 text-yellow-300 animate-pulse">R…ôqib g√∂zl…ônilir...</div>
                        </div>}
                    </div>
                );
            }

            if (screen === 'game') {
                return (
                    <div className="fixed inset-0 flex flex-col bg-table-base overflow-hidden">
                        {/* Header */}
                        <div className="flex justify-between items-center p-4 bg-black/40 text-white z-10">
                            <div className="flex items-center gap-2">
                                <div className="w-10 h-10 bg-gray-600 rounded-full flex items-center justify-center">üë§</div>
                                <div>{opponent ? (opponent.name || 'R…ôqib') : 'R…ôqib'}</div>
                            </div>
                            <div className={`px-4 py-1 rounded-full text-xs font-bold ${gameState?.currentPlayer === gameState?.playerId ? 'bg-yellow-500 text-black animate-pulse' : 'bg-gray-700'}`}>
                                {gameState?.currentPlayer === gameState?.playerId ? 'Sƒ∞Zƒ∞N N√ñVB∆èNƒ∞Z' : 'R∆èQƒ∞B OYNAYIR'}
                            </div>
                        </div>

                        {/* Board */}
                        <div className="flex-1 relative overflow-hidden" ref={boardContainerRef}>
                            <div className="domino-board-inner" style={{
                                transform: `translate(${boardPosition.x}px, ${boardPosition.y}px) scale(${boardZoom})`
                            }}>
                                {renderBoardTiles.map((t, i) => (
                                    <div key={i} className="board-tile-wrapper" style={{ left: t.x, top: t.y }}>
                                        <DominoTile values={t.tile} isBoardTile={true} direction={t.dir} />
                                    </div>
                                ))}

                                {/* Indicators - simplified logic for demo */}
                                {validMoves.includes('start') && (
                                    <div className="valid-move-indicator" style={{ left: 0, top: 0, width: '80px', height: '40px' }} onClick={() => playTile('start')}>BA≈ûLA</div>
                                )}
                            </div>
                        </div>

                        {/* Hand */}
                        <div className="bg-black/80 p-2 z-10">
                            <div className="hand-tiles-container">
                                {myHand.map((tile, i) => (
                                    <div key={i} className="hand-tile-wrapper">
                                        <DominoTile
                                            values={tile}
                                            onClick={() => {
                                                if (selectedTileIndex === i) { setSelectedTileIndex(null); setValidMoves([]); }
                                                else { setSelectedTileIndex(i); setValidMoves(['left', 'right']); /* Simulating valid moves for UI click */ }
                                            }}
                                            isSelected={selectedTileIndex === i}
                                        />
                                    </div>
                                ))}
                            </div>
                            <div className="flex justify-between mt-2 px-4">
                                <button className="text-white text-xs bg-red-600 px-3 py-1 rounded" onClick={() => { setScreen('lobby'); sendMessage({ type: 'leaveGame' }) }}>√áƒ±xƒ±≈ü</button>
                                <button className="text-white text-xs bg-blue-600 px-3 py-1 rounded" onClick={() => sendMessage({ type: 'drawFromMarket' })}>Bazar</button>
                            </div>
                        </div>
                    </div>
                );
            }

            return null;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DominoGame />);
    </script>
</body>

</html>
